{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#about-the-library","title":"About the library","text":"<p><code>react-generic-state-hooks</code> provides a simple way to create reusable data sources. The library allows you to create generic hooks for managing application data.</p>"},{"location":"#generic-hooks","title":"Generic hooks","text":"<p>Generic hooks have the ability to store and return data and are fully reusable. It means that data stored in them is persisted during the app's lifecycle. Additionally, the persistence time is configurable, and depends on the storage type used.</p>"},{"location":"#types-of-generic-hooks","title":"Types of generic hooks","text":"<ul> <li><code>useValue</code> - basic hook with a simple API for reading and storing values</li> <li><code>useList</code> - hook with specialized API dedicated to use with lists and sets</li> <li><code>useRecord</code> - hook with specialized API for managing record-like data structures</li> </ul>"},{"location":"#data-storages","title":"Data storages","text":"<p>You can choose the storage engine in which data will be stored. Available storages:</p> <ul> <li><code>inMemory</code> - application's memory</li> <li><code>localStorage</code> - web browser's local storage</li> <li><code>sessionStorage</code> - web browser's session storage</li> <li><code>redux</code> - Redux library (<code>react-redux</code> needs to be installed to use Redux as a storage)</li> </ul>"},{"location":"basic-usage/","title":"Basic Usage","text":""},{"location":"basic-usage/#generating-hooks","title":"Generating hooks","text":"<p>First, we need to create generic hooks that we can later use directly in the application or as a base for custom hooks.</p>"},{"location":"basic-usage/#hooks-creation-function-types","title":"Hooks creation function types","text":"<p>For creating generic hooks we can use four functions. Each of them stores data in different type of storage:</p> <ul> <li><code>createInMemoryStateHooks</code> stores data in the application memory</li> <li><code>createLocalStorageStateHooks</code> stores data in local storage</li> <li><code>createSessionStorageStateHooks</code> stores data in session storage</li> <li><code>createReduxStateHooks</code> stores data in Redux</li> </ul>"},{"location":"basic-usage/#usage-examples","title":"Usage examples","text":"InMemoryLocalStorageSessionStorageRedux inMemoryStateHooks.ts<pre><code>import { createInMemoryStateHooks } from 'react-generic-state-hooks';\n\nexport const { useValue, useList, useRecord\n} = createInMemoryStateHooks('my-namespace');\n</code></pre> localStorageStateHooks.ts<pre><code>import { createLocalStorageStateHooks } from 'react-generic-state-hooks';\n\nexport const { useValue, useList, useRecord\n} = createLocalStorageStateHooks('my-namespace');\n</code></pre> sessionStorageStateHooks.ts<pre><code>import { createSessionStorageStateHooks } from 'react-generic-state-hooks';\n\nexport const { useValue, useList, useRecord\n} = createSessionStorageStateHooks('my-namespace');\n</code></pre> reduxStateHooks.ts<pre><code>import { createReduxStateHooks } from 'react-generic-state-hooks';\n\nexport const { slice, createSelector, createAction,\n  useValue, useList, useRecord\n} = createReduxStateHooks('my-namespace');\n\n// --------------------------------------------------------------\n// RootReducer: Connect generated \"slice.reducer\" to Redux store:\nimport { slice } from './ReduxGenericStateHooks';\n\nconst rootReducer = combineReducers({\n  [slice.name]: slice.reducer\n});\n\nexport { rootReducer };\n</code></pre> <p>Now, you can use them anywhere in your application:</p> MyComponent.tsx<pre><code>import { useValue } from './inMemoryStateHooks';\n\nconst MyComponent = () =&gt; {\n  const [value, setValue] = useValue('counter', 0);\n  return (\n    &lt;&gt;\n      &lt;div&gt;count: {value}&lt;/div&gt;\n      &lt;button onClick={() =&gt; setValue(value + 1)}&gt;click me&lt;/button&gt;\n    &lt;/&gt;\n  );\n}\n</code></pre>"},{"location":"basic-usage/#creating-custom-hooks","title":"Creating Custom Hooks","text":"<p>If you plan to use the same data in multiple places in the application, a better approach would be to create dedicated hooks based on generic hooks.</p>"},{"location":"basic-usage/#custon-hook-example","title":"Custon hook example","text":"<p>useCounter.ts<pre><code>import { useValue } from './inMemoryStateHooks';\n\nconst initialValue = 0;\nexport const useCounter = () =&gt; useValue('counter', initialValue);\n</code></pre> Just like generic hooks, you can use custom hooks anywhere in your application: MyComponent.tsx<pre><code>import { useCounter } from './useCounter';\n\nconst MyComponent = () =&gt; {\n  const [value, setValue] = useCounter();\n  return (\n    &lt;&gt;\n      &lt;div&gt;count: {value}&lt;/div&gt;\n      &lt;button onClick={() =&gt; setValue(value + 1)}&gt;click me&lt;/button&gt;\n    &lt;/&gt;\n  );\n}\n</code></pre></p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#package-installation","title":"Package installation","text":"<p>To install, simply run the following command: <pre><code>npm install react-generic-state-hooks\n</code></pre></p>"},{"location":"installation/#usage-with-redux","title":"Usage with redux","text":"<p>If you plan to use Redux as a storage, <code>react-redux</code> is required to be installed: <pre><code>npm install react-redux\n</code></pre></p>"},{"location":"usage-with-redux/","title":"Usage with Redux","text":""},{"location":"usage-with-redux/#creating-generic-hooks","title":"Creating Generic Hooks","text":"<p><code>createReduxStateHooks()</code> returns generic hooks, <code>slice</code> (reducer and its name),  <code>createSelector</code> and <code>createAction</code> helpers to work with Redux.</p> myNamespaceReduxGenericHooks.ts<pre><code>import { createReduxStateHooks } from 'react-generic-state-hooks';\n\nexport const {\n  useValue, useList, useRecord, \n  slice, createSelector, createAction  \n} = createReduxStateHooks('my-namespace');\n</code></pre>"},{"location":"usage-with-redux/#connecting-to-redux","title":"Connecting to redux","text":"<p>Generated <code>slice</code> object contains two properties: <code>name</code> - the key for connecting reducer to rootReducer,  and <code>reducer</code> - reducer itself. rootReducer.ts<pre><code>import { slice } from './myNamespaceReduxGenericHooks.ts';\n\nconst rootReducer = combineReducers({\n  [slice.name]: slice.reducer,\n  // ...other reducers\n});\n\nexport { rootReducer };\n</code></pre></p>"},{"location":"usage-with-redux/#creating-a-custom-hook-selector-and-action","title":"Creating a custom hook, selector and action","text":"<p>There is no need to create a selector or action to use hooks with Redux. Only if you want to manually dispatch changes or manually select value from Redux, you will need to generate dedicated selectors and actions.</p> useCounter.ts<pre><code>import { useValue, createSelector, createAction\n} from './myNamespaceReduxGenericHooks.ts';\n\nconst key = 'counter';\nconst initialValue = 0;\n\nexport const useCounter = () =&gt; useValue(key, initialValue);\nexport const selectCounter = createSelector(key, initialValue);\nexport const setCounter = createAction(key);\n</code></pre>"},{"location":"usage-with-redux/#hook-usage","title":"Hook Usage","text":"MyComponent.tsx<pre><code>import { useCounter } from './useCounter';\n\nconst MyComponent = () =&gt; {\n  const [value, setValue] = useCounter();\n  return (\n    &lt;&gt;\n      &lt;div&gt;count: {value}&lt;/div&gt;\n      &lt;button onClick={() =&gt; setValue(value + 1)}&gt;click me&lt;/button&gt;\n    &lt;/&gt;\n  );\n}\n</code></pre>"},{"location":"usage-with-redux/#selector-and-action-usage","title":"Selector and Action Usage","text":"MyComponent.tsx<pre><code>import { useSelector, useDispatch } from 'react-redux';\nimport { selectCounter, setCounter } from './useCounter';\n\nconst MyComponent = () =&gt; {\n  const dispatch = useDispatch();  \n  const value = useSelector(selectCounter);\n\n  return (\n    &lt;&gt;\n      &lt;div&gt;count: {value}&lt;/div&gt;\n      &lt;button onClick={() =&gt; dispatch(setCounter(value + 1))}&gt;click me&lt;/button&gt;\n    &lt;/&gt;\n  );\n}\n</code></pre>"},{"location":"hooks-api/use-list/","title":"useList","text":""},{"location":"hooks-api/use-list/#uselist-interfaces","title":"useList Interfaces","text":"useList parameters<pre><code>interface useList&lt;ListItem&gt; {\n  (\n      key: string,\n      initialValue: ListItem[] = [],\n      defaultOptions?: ListOptions&lt;ListItem&gt;\n  ): UseListApi&lt;ListItem&gt;\n}\n\ntype ListOptions&lt;ListItem&gt; = {\n    prepend?: boolean;\n    distinct?: boolean;\n    skipIfExist?: boolean;\n    areEqual?: EqualityFn&lt;ListItem&gt; = (a: ListItem, b: ListItem) =&gt; a === b;\n};\n\ninterface EqualityFn&lt;ListItem&gt; {\n    (t1: ListItem, t2: ListItem): boolean;\n}\n</code></pre> useList returned values<pre><code>type UseListApi&lt;ListItem&gt; = [\n    list: ListItem[],\n    addItem: (listItem: ListItem) =&gt; void,\n    removeItem: (listItem: ListItem) =&gt; void,\n    setList: SetValueFn&lt;ListItem[]&gt;,\n];\n\ninterface SetValueFn&lt;List&gt; {\n  (value: List): void;\n  (valueFn: (oldValue: List) =&gt; List): void;\n}\n</code></pre>"},{"location":"hooks-api/use-list/#uselist-api","title":"useList API","text":"<pre><code>type Item = { id: string; text: string };\n\nconst listOptions: ListOptions&lt;Item&gt; = {\n    distinct: true,\n    skipIfExist: true,\n    prepend: true,\n    areEqual: (a, b) =&gt; a.id === b.id\n}\n\nconst [list, addItem, removeItem, setList] = useList('my-key', [], listOptions);\n</code></pre>"},{"location":"hooks-api/use-list/#adding-items","title":"Adding items","text":""},{"location":"hooks-api/use-list/#you-can-add-item-at-the-beginning-or-at-th-end-of-the-list","title":"You can add item at the beginning or at th end of the list.","text":"<p>As default, new items are added at the end of the list. With <code>prepend</code> option you can add new items at the beginning of the list.</p> Append itemsPrepend items New items are added at the end of the list (default behaviour)<pre><code>const [, addItem] = useList&lt;string&gt;('some-key');\n\nconst addText = useCallback((item: string) =&gt; addItem(item), []);\n</code></pre> New items are added at the beginning of the list<pre><code>const listOptions: ListOptions&lt;string&gt; = { prepend: true };\nconst [, addItem] = useList&lt;string&gt;('some-key', [], listOptions);\n\nconst addText = useCallback((item: string) =&gt; addItem(item), []);\n</code></pre>"},{"location":"hooks-api/use-list/#add-item-with-distinction-check","title":"Add item with distinction check","text":"<p>With <code>distinct</code> option you can enable distinction check.</p> <p>As default this will replace existing items with the new one. It means that new items are always added  at the beginning or at the end of the list, and existing items are removed.</p> scalar items listcomplex items list <pre><code>const listOptions: ListOptions&lt;string&gt; = { distinct: true };\nconst [, addItem] = useList&lt;string&gt;('some-key', [], listOptions);\n\nconst addText = useCallback((item: string) =&gt; addItem(item), []);\n</code></pre> <pre><code>type Item = { id: string; text: string; }\n\nconst listOptions: ListOptions&lt;Item&gt; = {\n    distinct: true,\n    areEqual: (a: Item, b: Item) =&gt; a.id === b.id\n};\n\nconst [, addItem] = useList&lt;Item&gt;('some-key', [], listOptions);\n\nconst addText = useCallback((item: Item) =&gt; addItem(item), []);\n</code></pre> <p>With <code>skipIfExist</code> option you can change this behaviour.</p> <p>If provided, update will happen only if item does not exist in the list. Otherwise it will do nothing.</p> scalar items listcomplex items list <pre><code>const listOptions: ListOptions&lt;string&gt; = { distinct: true, skipIfExist: true };\nconst [, addItem] = useList&lt;string&gt;('some-key', [], listOptions);\n\nconst addText = useCallback((item: string) =&gt; addItem(item), []);\n</code></pre> <pre><code>type Item = { id: string; text: string; }\n\nconst listOptions: ListOptions&lt;Item&gt; = {\n    distinct: true,\n    skipIfExist: true,\n    areEqual: (a: Item, b: Item) =&gt; a.id === b.id\n};\n\nconst [, addItem] = useList&lt;Item&gt;('some-key', [], listOptions);\n\nconst addText = useCallback((item: Item) =&gt; addItem(item), []);\n</code></pre>"},{"location":"hooks-api/use-list/#removing-items","title":"Removing items","text":""},{"location":"hooks-api/use-list/#remove-item","title":"Remove item","text":"scalar items listcomplex items list <pre><code>const [,, removeItem] = useList&lt;string&gt;('some-key');\n\nconst removeText = useCallback((item: string) =&gt; removeItem(item), []);\n</code></pre> <pre><code>type Item = { id: string, text: string };\n\nconst listOptions = {\n    areEqual: (a: Item, b: Item) =&gt; a.id === b.id\n}\nconst [,, removeItem] = useList&lt;Item&gt;('some-key', [], listOptions);\n\nconst removeElement = useCallback((item: Item) =&gt; removeItem(item), []);\n</code></pre>"},{"location":"hooks-api/use-list/#setting-new-lists","title":"Setting new lists","text":""},{"location":"hooks-api/use-list/#set-new-list-by-new-value","title":"Set new list by new value","text":"<p>You can set new list by calling <code>setList</code> with new list parameter. <pre><code>const [,,, setList] = useList&lt;string&gt;('some-key');\n\nconst setNewList = useCallback((newList: string[]) =&gt; setList(newList), []);\n</code></pre></p>"},{"location":"hooks-api/use-list/#set-new-list-by-callback","title":"Set new list by callback","text":"<p>If value provided to <code>setList</code> is a function, it will be called with one parameter oldValue,  and returned value from this function will be set as new list. </p> <p>With this mechanism you can resolve new value based on old value. <pre><code>const [,,, setList] = useList&lt;string&gt;('some-key');\n\nconst setNewListIfEmpty = useCallback((newList: string[]) =&gt; \n    setList((oldList: string[]) =&gt; {\n        return (oldList.length &gt; 0) ? oldList : newList;\n    }\n), []);\n</code></pre></p>"},{"location":"hooks-api/use-value/","title":"useValue","text":""},{"location":"hooks-api/use-value/#interface-definition","title":"Interface definition","text":"<pre><code>interface UseValue&lt;Value&gt; {\n  (key: string, initialValue: Value): UseValueApi&lt;Value&gt;\n}\n\ntype UseValueApi&lt;Value&gt; = \n  [value: Value, setValue: SetValueFn&lt;Value&gt;]\n\ninterface SetValueFn&lt;T&gt; {\n  (value: T): void;\n  (valueFn: (oldValue: T) =&gt; T): void;\n}\n</code></pre>"},{"location":"hooks-api/use-value/#update-data-directly","title":"Update data directly","text":"<pre><code>const [value, setValue] = useValue('some-key', 0);\n\nconst increment = useCallback(() =&gt; setValue(value + 1), [value]);\n</code></pre>"},{"location":"hooks-api/use-value/#update-data-by-callback-function","title":"Update data by callback function","text":"<p>In this approach we have no dependencies in <code>useCallback</code> hook. <pre><code>const [value, setValue] = useValue('some-key', 0);\n\nconst increment = useCallback(() =&gt; setValue((oldValue) =&gt; oldValue + 1), []);\n</code></pre></p>"}]}