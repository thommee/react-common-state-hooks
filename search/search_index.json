{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>React Generic State Hooks provides a unified, consistent API for reading and writing data. With dedicated hooks for key data types, you have full control over how your data is managed.</p> <p>It supports the most essential types of storages: inMemory, localStorage, sessionStorage, redux. Additionally, the data stored in them persists throughout the application's runtime, so you can reuse them in any place of your application with the same data.</p> <p>If you use it with Redux, you no longer need to manually create actions and reducers.  Everything will be handled for you.</p>"},{"location":"#types-of-hooks","title":"Types of hooks","text":"<ul> <li><code>useValue</code> - basic hook with a simple API for reading and storing values</li> <li><code>useRecord</code> - hook with specialized API for managing record-like data structures</li> <li><code>useList</code> - hook with specialized API dedicated to use with lists and sets</li> </ul>"},{"location":"#data-storages","title":"Data storages","text":"<p>You can choose the storage engine within data will be stored:</p> <ul> <li><code>inMemory</code> - application memory</li> <li><code>localStorage</code> - web browser local storage</li> <li><code>sessionStorage</code> - web browser session storage</li> <li><code>redux</code> - redux library</li> </ul>"},{"location":"#_1","title":"Introduction","text":""},{"location":"basic-usage/","title":"Basic Usage","text":""},{"location":"basic-usage/#generating-hooks","title":"Generating hooks","text":"<p>First, we need to create generic hooks that we can later use directly in the application or as a base for custom hooks.</p>"},{"location":"basic-usage/#hooks-creation-function-types","title":"Hooks creation function types","text":"<p>For creating generic hooks we can use four functions. Each of them stores data in different type of storage:</p> <ul> <li><code>createInMemoryStateHooks</code> stores data in the application memory</li> <li><code>createLocalStorageStateHooks</code> stores data in local storage</li> <li><code>createSessionStorageStateHooks</code> stores data in session storage</li> <li><code>createReduxStateHooks</code> stores data in Redux</li> </ul>"},{"location":"basic-usage/#usage-examples","title":"Usage examples","text":"InMemoryLocalStorageSessionStorageRedux inMemoryStateHooks.ts<pre><code>import { createInMemoryStateHooks } from 'react-generic-state-hooks';\n\nexport const { useValue, useList, useRecord\n} = createInMemoryStateHooks('my-namespace');\n</code></pre> localStorageStateHooks.ts<pre><code>import { createLocalStorageStateHooks } from 'react-generic-state-hooks';\n\nexport const { useValue, useList, useRecord\n} = createLocalStorageStateHooks('my-namespace');\n</code></pre> sessionStorageStateHooks.ts<pre><code>import { createSessionStorageStateHooks } from 'react-generic-state-hooks';\n\nexport const { useValue, useList, useRecord\n} = createSessionStorageStateHooks('my-namespace');\n</code></pre> reduxStateHooks.ts<pre><code>import { createReduxStateHooks } from 'react-generic-state-hooks';\n\nexport const { slice, createSelector, createAction,\n  useValue, useList, useRecord\n} = createReduxStateHooks('my-namespace');\n\n// --------------------------------------------------------------\n// RootReducer: Connect generated \"slice.reducer\" to Redux store:\nimport { slice } from './ReduxGenericStateHooks';\n\nconst rootReducer = combineReducers({\n  [slice.name]: slice.reducer\n});\n\nexport { rootReducer };\n</code></pre> <p>Now, you can use them anywhere in your application:</p> MyComponent.tsx<pre><code>import { useValue } from './inMemoryStateHooks';\n\nconst MyComponent = () =&gt; {\n  const [value, setValue] = useValue('counter', 0);\n  return (\n    &lt;&gt;\n      &lt;div&gt;count: {value}&lt;/div&gt;\n      &lt;button onClick={() =&gt; setValue(value + 1)}&gt;click me&lt;/button&gt;\n    &lt;/&gt;\n  );\n}\n</code></pre>"},{"location":"basic-usage/#creating-custom-hooks","title":"Creating Custom Hooks","text":"<p>If you plan to use the same data in multiple places in the application, a better approach would be to create dedicated hooks based on generic hooks.</p>"},{"location":"basic-usage/#custon-hook-example","title":"Custon hook example","text":"<p>useCounter.ts<pre><code>import { useValue } from './inMemoryStateHooks';\n\nconst initialValue = 0;\nexport const useCounter = () =&gt; useValue('counter', initialValue);\n</code></pre> Just like generic hooks, you can use custom hooks anywhere in your application: MyComponent.tsx<pre><code>import { useCounter } from './useCounter';\n\nconst MyComponent = () =&gt; {\n  const [value, setValue] = useCounter();\n  return (\n    &lt;&gt;\n      &lt;div&gt;count: {value}&lt;/div&gt;\n      &lt;button onClick={() =&gt; setValue(value + 1)}&gt;click me&lt;/button&gt;\n    &lt;/&gt;\n  );\n}\n</code></pre></p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#package-installation","title":"Package installation","text":"<p>To install, simply run the following command: <pre><code>npm install react-generic-state-hooks\n</code></pre></p>"},{"location":"installation/#usage-with-redux","title":"Usage with redux","text":"<p>If you plan to use Redux as a storage, <code>react-redux</code> is required to be installed: <pre><code>npm install react-redux\n</code></pre></p>"},{"location":"usage-with-redux/","title":"Usage with Redux","text":""},{"location":"usage-with-redux/#creating-generic-hooks","title":"Creating Generic Hooks","text":"<p><code>createReduxStateHooks()</code> returns generic hooks, <code>slice</code> (reducer and its name),  <code>createSelector</code> and <code>createAction</code> helpers to work with Redux.</p> myNamespaceReduxGenericHooks.ts<pre><code>import { createReduxStateHooks } from 'react-generic-state-hooks';\n\nexport const {\n  useValue, useList, useRecord, \n  slice, createSelector, createAction  \n} = createReduxStateHooks('my-namespace');\n</code></pre>"},{"location":"usage-with-redux/#connecting-to-redux","title":"Connecting to redux","text":"<p>Generated <code>slice</code> object contains two properties: <code>name</code> - the key for connecting reducer to rootReducer,  and <code>reducer</code> - reducer itself. rootReducer.ts<pre><code>import { slice } from './myNamespaceReduxGenericHooks.ts';\n\nconst rootReducer = combineReducers({\n  [slice.name]: slice.reducer,\n  // ...other reducers\n});\n\nexport { rootReducer };\n</code></pre></p>"},{"location":"usage-with-redux/#creating-a-custom-hook-selector-and-action","title":"Creating a custom hook, selector and action","text":"<p>There is no need to create a selector or action to use hooks with Redux. Only if you want to manually dispatch changes or manually select value from Redux, you will need to generate dedicated selectors and actions.</p> useCounter.ts<pre><code>import { useValue, createSelector, createAction\n} from './myNamespaceReduxGenericHooks.ts';\n\nconst key = 'counter';\nconst initialValue = 0;\n\nexport const useCounter = () =&gt; useValue(key, initialValue);\nexport const selectCounter = createSelector(key, initialValue);\nexport const setCounter = createAction(key);\n</code></pre>"},{"location":"usage-with-redux/#hook-usage","title":"Hook Usage","text":"MyComponent.tsx<pre><code>import { useCounter } from './useCounter';\n\nconst MyComponent = () =&gt; {\n  const [value, setValue] = useCounter();\n  return (\n    &lt;&gt;\n      &lt;div&gt;count: {value}&lt;/div&gt;\n      &lt;button onClick={() =&gt; setValue(value + 1)}&gt;click me&lt;/button&gt;\n    &lt;/&gt;\n  );\n}\n</code></pre>"},{"location":"usage-with-redux/#selector-and-action-usage","title":"Selector and Action Usage","text":"MyComponent.tsx<pre><code>import { useSelector, useDispatch } from 'react-redux';\nimport { selectCounter, setCounter } from './useCounter';\n\nconst MyComponent = () =&gt; {\n  const dispatch = useDispatch();  \n  const value = useSelector(selectCounter);\n\n  return (\n    &lt;&gt;\n      &lt;div&gt;count: {value}&lt;/div&gt;\n      &lt;button onClick={() =&gt; dispatch(setCounter(value + 1))}&gt;click me&lt;/button&gt;\n    &lt;/&gt;\n  );\n}\n</code></pre>"},{"location":"hooks-api/use-list/","title":"useList","text":""},{"location":"hooks-api/use-list/#uselist-interfaces","title":"useList Interfaces","text":"useList parameters<pre><code>interface useList&lt;ListItem&gt; {\n  (\n      key: string,\n      initialValue: ListItem[],\n      defaultOptions?: ListOptions&lt;ListItem&gt;\n  ): UseListApi&lt;ListItem&gt;\n}\n\ntype ListOptions&lt;ListItem&gt; = {\n    prepend?: boolean;\n    unique?: boolean;\n    skipIfExist?: boolean;\n    areEqual?: EqualityFn&lt;ListItem&gt;;\n};\n\ninterface EqualityFn&lt;ListItem&gt; {\n    (t1: ListItem, t2: ListItem): boolean;\n}\n</code></pre> useList returned values<pre><code>type UseListApi&lt;ListItem&gt; = [\n    list: ListItem[],\n    addItem: (listItem: ListItem) =&gt; void,\n    removeItem: (listItem: ListItem) =&gt; void,\n    setList: SetValue&lt;ListItem[]&gt;,\n];\n\ninterface SetValue&lt;List&gt; {\n  (value: List): void;\n  (valueFn: (oldValue: List) =&gt; List): void;\n}\n</code></pre>"},{"location":"hooks-api/use-list/#uselist-api","title":"useList API","text":"<pre><code>type Item = { id: string; text: string };\n\nconst listOptions: ListOptions&lt;Item&gt; = {\n    unique: true,\n    skipIfExist: true,\n    prepend: true,\n    areEqual: (a: Item, b: Item) =&gt; a.id === b.id\n}\n\nconst [list, addItem, removeItem, setList] = useList('my-key', [], listOptions);\n</code></pre>"},{"location":"hooks-api/use-list/#adding-items","title":"Adding items","text":""},{"location":"hooks-api/use-list/#append-or-prepend","title":"Append or prepend?","text":"<p>As default, new items are added at the end of the list. With <code>prepend</code> option you can add new items at the beginning of the list.</p> appending itemsprepending items New items are added at the end of the list (default behavior)<pre><code>const [list, addItem] = useList&lt;string&gt;('key', ['a', 'b', 'c']);\n\n                // list: ['a', 'b', 'c']\naddItem('b');   // list: ['a', 'b', 'c', 'b']\naddItem('x');   // list: ['a', 'b', 'c', 'b', 'x']\n</code></pre> New items are added at the beginning of the list<pre><code>const listOptions: ListOptions&lt;string&gt; = { prepend: true };\nconst [list, addItem] = useList&lt;string&gt;('key', ['a', 'b', 'c'], listOptions);\n\n                // list: ['a', 'b', 'c']\naddItem('b');   // list: ['b', 'a', 'b', 'c']\naddItem('x');   // list: ['x', 'b', 'a', 'b', 'c']\n</code></pre>"},{"location":"hooks-api/use-list/#uniqueness-check","title":"Uniqueness check","text":"<p>The <code>unique</code> option enables a mechanism ensuring the uniqueness of elements in a list.</p> <p>When activated, attempting to add an element that already exists on the list results  in the removal of the existing element and the addition of the new one at the beginning/end of the list.</p> <p>It means that new items are always added to the list, and existing ones are always removed.</p> <p>\"areEqual\" function</p> <p>Uniqueness check is done using the \"areEqual\" function.  By default, function performs shallow comparison between two list items<code>(a: ListItem, b: ListItem) =&gt; a === b;</code>. You can modify this behavior by defining your own comparison function in the \"ListOptions.areEqual\" parameter.</p> simple list itemscomplex list items <pre><code>const listOptions: ListOptions&lt;string&gt; = { unique: true };\nconst [list, addItem] = useList&lt;string&gt;('some-key', ['a', 'b', 'c'], listOptions);\n\n                // list: ['a', 'b', 'c']\naddItem('b');   // list: ['a', 'c', 'b']\naddItem('x');   // list: ['a', 'c', 'b', 'x']\n</code></pre> <pre><code>type Item = { id: string; }\n\nconst listOptions: ListOptions&lt;Item&gt; = {\n    unique: true,\n    areEqual: (a: Item, b: Item) =&gt; a.id === b.id\n};\nconst initialValue = [{ id: 'a' }, { id: 'b' }, { id: 'c' }];\nconst [list, addItem] = useList&lt;Item&gt;('some-key', initialValue, listOptions);\n\n                // list: [{ id: 'a' }, { id: 'b' }, { id: 'c' }]\naddItem('b');   // list: [{ id: 'a' }, { id: 'c' }, { id: 'b' }]\naddItem('x');   // list: [{ id: 'a' }, { id: 'c' }, { id: 'b' }, { id: 'x' }]\n</code></pre> <p>With <code>skipIfExist</code> option you can change this behavior.</p> <p>By default, <code>unique</code> option is set to the \"replace\" mode. However, it can be customized with the additional <code>skipIfExist</code> option. When this option is enabled, attempting to add an existing element does not affect the list, and the operation is ignored.</p> simple list itemscomplex list items <pre><code>const listOptions: ListOptions&lt;string&gt; = { unique: true, skipIfExist: true };\nconst [, addItem] = useList&lt;string&gt;('some-key', ['a', 'b', 'c'], listOptions);\n\n                // list: ['a', 'b', 'c']\naddItem('b');   // list: ['a', 'b', 'c']\naddItem('x');   // list: ['a', 'b', 'c', 'x']    \n</code></pre> <pre><code>type Item = { id: string; text: string; }\n\nconst listOptions: ListOptions&lt;Item&gt; = {\n    unique: true,\n    skipIfExist: true,\n    areEqual: (a: Item, b: Item) =&gt; a.id === b.id\n};\nconst initialValue = [{ id: 'a' }, { id: 'b' }, { id: 'c' }];\nconst [list, addItem] = useList&lt;Item&gt;('some-key', initialValue, listOptions);\n\n                // list: [{ id: 'a' }, { id: 'b' }, { id: 'c' }]\naddItem('b');   // list: [{ id: 'a' }, { id: 'b' }, { id: 'c' }]\naddItem('x');   // list: [{ id: 'a' }, { id: 'b' }, { id: 'c' }, { id: 'x' }]\n</code></pre>"},{"location":"hooks-api/use-list/#removing-items","title":"Removing items","text":""},{"location":"hooks-api/use-list/#remove-item","title":"Remove item","text":"simple list itemscomplex list items <pre><code>const [list,, removeItem] = useList&lt;string&gt;('some-key', ['a', 'b', 'c']);\n\n                    // list: ['a', 'b', 'c']\nremoveItem('b');    // list: ['a', 'c']\nremoveItem('x');    // list: ['a', 'c']  \n</code></pre> <pre><code>type Item = { id: string, text: string };\n\nconst listOptions = {\n    areEqual: (a: Item, b: Item) =&gt; a.id === b.id\n}\nconst initialValue = [{ id: 'a' }, { id: 'b' }, { id: 'c' }];\nconst [list,, removeItem] = useList&lt;Item&gt;('key', initialValue, listOptions);\n\n                            // list: [{ id: 'a' }, { id: 'b' }, { id: 'c' }]\nremoveItem({ id: 'b' });    // list: [{ id: 'a' }, { id: 'c' }]\nremoveItem({ id: 'x' });    // list: [{ id: 'a' }, { id: 'c' }]\n</code></pre>"},{"location":"hooks-api/use-list/#setting-new-lists","title":"Setting new lists","text":""},{"location":"hooks-api/use-list/#set-new-list-by-new-value","title":"Set new list by new value","text":"<p>You can set new list by calling <code>setList</code> with new list parameter. <pre><code>const [list,,, setList] = useList&lt;string&gt;('some-key', ['a', 'b', 'c']);\n\n                      // list: ['a', 'b', 'c']\nsetList(['x', 'y']);  // list: ['x', 'y']\nsetList(['a']);       // list: ['a']\n</code></pre></p>"},{"location":"hooks-api/use-list/#set-new-list-by-callback","title":"Set new list by callback","text":"<p>If value provided to <code>setList</code> is a function, it will be called with oldValue parameter,  and returned value from this function will be set as new list. </p> <p>With this mechanism you can resolve new value based on old value. <pre><code>const [,,, setList] = useList&lt;string&gt;('some-key', []);\n\nconst setNewListIfEmpty = (newList: string[]) =&gt; \n    setList((oldList: string[]) =&gt; {\n        return (oldList.length &gt; 0) ? oldList : newList;\n    }\n);\n                                // list: []\nsetNewListIfEmpty(['x', 'y']);  // list: ['x', 'y']\nsetNewListIfEmpty(['a']);       // list: ['x', 'y']\n</code></pre></p>"},{"location":"hooks-api/use-record/","title":"useRecord","text":""},{"location":"hooks-api/use-record/#userecord-interfaces","title":"useRecord Interfaces","text":"useRecord parameters<pre><code>interface useRecord&lt;RecordItem&gt; {\n  (key: string, initialValue?: Record&lt;string, RecordItem&gt;\n  ): UseRecordApi&lt;RecordItem&gt;\n}\n</code></pre> useRecord returned values<pre><code>type UseRecordApi&lt;RecordItem&gt; = [\n  record: Record&lt;string, RecordItem&gt;,\n  addItem: (key: string, recordItem: RecordItem) =&gt; void,\n  removeItem: (key: string) =&gt; void,\n  setRecord: SetValue&lt;Record&lt;string, RecordItem&gt;&gt;,\n];\n\ninterface SetValue&lt;Record&gt; {\n  (value: Record): void;\n  (valueFn: (oldValue: Record) =&gt; Record): void;\n}\n</code></pre>"},{"location":"hooks-api/use-record/#userecord-api","title":"useRecord API","text":"<pre><code>const [record, addItem, removeItem, setRecord] = useRecord('my-key', {});\n</code></pre>"},{"location":"hooks-api/use-record/#adding-items","title":"Adding items","text":"<pre><code>const [record, addItem] = useRecord&lt;string&gt;('some-key');\n\n                    // record: {}\naddItem('a', 'A');  // record: { a: 'A' }\naddItem('b', 'B');  // record: { a: 'A', b: 'B' }\naddItem('a', 'C');  // record: { a: 'C', b: 'B' }\n</code></pre>"},{"location":"hooks-api/use-record/#removing-items","title":"Removing items","text":""},{"location":"hooks-api/use-record/#remove-item","title":"Remove item","text":"<pre><code>const initialValue = { a: 'A', b: 'B', c: 'C' };\nconst [,, removeItem] = useRecord&lt;string&gt;('some-key', initialValue);\n\n                  // record: { a: 'A', b: 'B', c: 'C' }\nremoveItem('b');  // record: { a: 'A', c: 'C' }\nremoveItem('a');  // record: { c: 'C' }\nremoveItem('x');  // record: { c: 'C' }\n</code></pre>"},{"location":"hooks-api/use-record/#setting-new-records","title":"Setting new records","text":""},{"location":"hooks-api/use-record/#set-new-record-by-new-value","title":"Set new record by new value","text":"<p>You can set new record by calling <code>setRecord</code> with newRecord parameter. <pre><code>const [record,,, setRecord] = useRecord&lt;string&gt;('some-key', { a: 'A' });\n\n                        // record: { a: 'A' }\nsetRecord({ b: 'B' });  // record: { b: 'B' }\n</code></pre></p>"},{"location":"hooks-api/use-record/#set-new-record-by-callback","title":"Set new record by callback","text":"<p>If value provided to <code>setRecord</code> is a function, it will be called with oldValue parameter, and returned value from this function will be set as new record.</p> <p>With this mechanism you can resolve new value based on old value. <pre><code>const [,,, setRecord] = useRecord&lt;string&gt;('some-key');\n\nconst setNewRecordIfEmpty = (newRecord: Record&lt;string, string&gt;) =&gt; \n    setRecord((oldRecord: Record&lt;string, string&gt;) =&gt; {\n        return (Object.keys(oldRecord).length &gt; 0) ? oldRecord : newRecord;\n    }\n);\n                                  // record: {}\nsetNewRecordIfEmpty({ b: 'B' });  // record: { b: 'B' }\nsetNewRecordIfEmpty({ c: 'C' });  // record: { b: 'B' }\n</code></pre></p>"},{"location":"hooks-api/use-value/","title":"useValue","text":""},{"location":"hooks-api/use-value/#interface-definition","title":"Interface definition","text":"<p>useValue parameters<pre><code>interface UseValue&lt;Value&gt; {\n  (key: string, initialValue: Value): UseValueApi&lt;Value&gt;\n}\n</code></pre> useValue returned values<pre><code>type UseValueApi&lt;Value&gt; = \n  [value: Value, setValue: SetValue&lt;Value&gt;]\n\ninterface SetValue&lt;Value&gt; {\n  (value: Value): void;\n  (valueFn: (oldValue: Value) =&gt; Value): void;\n}\n</code></pre></p>"},{"location":"hooks-api/use-value/#update-data-by-new-value-directly","title":"Update data by new value directly","text":"<pre><code>const [value, setValue] = useValue&lt;number&gt;('some-key', 0);\n\nconst increment = () =&gt; setValue(value + 1);\n\nincrement();  // value: 1\nincrement();  // value: 2\nincrement();  // value: 3\n</code></pre>"},{"location":"hooks-api/use-value/#update-data-by-callback","title":"Update data by callback","text":"<pre><code>const [value, setValue] = useValue&lt;number&gt;('some-key', 0);\n\nconst increment = () =&gt; setValue((oldValue: number) =&gt; oldValue + 1);\n\nincrement();  // value: 1\nincrement();  // value: 2\nincrement();  // value: 3\n</code></pre>"}]}